<h2 id="220106thu">22.01.06.Thu</h2>
<ul>
  <li><a href="https://hongshin.github.io/pubs/ase21-industry.pdf">ase21-industry</a> 논문을 읽기 시작했다.</li>
  <li>Ubuntu 서버와 맥OS에서 AFL++을 빌드하고 사용법을 익혔다.</li>
</ul>

<h2 id="220107fri">22.01.07.Fri</h2>
<ul>
  <li>AFL++을 사용해 오픈소스 프로젝트의 버그를 찾아보기 시작했다.</li>
  <li><a href="https://github.com/orangeduck/mpc.git">mpc</a>의 <code class="language-plaintext highlighter-rouge">mpca_lang()</code>을 대상으로 AFL++을 사용해 보았다. » 버그 하나를 찾았다.</li>
</ul>

<h2 id="220110mon">22.01.10.Mon</h2>
<ul>
  <li>3일간 AFL++로 mpc를 fuzzing한 결과 생성된, timeout과 crash를 유발하는 input들을 사용해 버그 리포트 쓰기를 시작했다.
    <ul>
      <li>mpc의 소스코드에서 버그를 유발하는 <code class="language-plaintext highlighter-rouge">mpca_lang_st()</code>를 찾았다.</li>
    </ul>
  </li>
</ul>

<h2 id="220112wed">22.01.12.Wed</h2>
<ul>
  <li>mpc의 버그 리포트를 작성해 보았다. (<a href="https://docs.google.com/document/d/1R22LYgmuno2US1-xhmT_y323_q9ovz9OLAmwjUg_frUㄴ/edit?usp=sharing">link</a>)</li>
</ul>

<h2 id="220113thu">22.01.13.Thu</h2>
<ul>
  <li>AFL++에서 function coverage 정보를 얻기 위해 AFL++의 <a href="https://github.com/KimSeoYe/AFLplusplus.git">코드</a>를 살펴보기 시작했다.</li>
</ul>

<h2 id="220114fri">22.01.14.Fri</h2>
<ul>
  <li>AFL++이 효율성을 높이기 위해 execve() 없이 프로그램을 실행하는 방법에 대한 <a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">포스트</a>를 읽어보았다.</li>
</ul>

<h2 id="220117mon">22.01.17.Mon</h2>
<ul>
  <li>shared memory를 이해하기 위해 Operating System Concepts 10th edition의 IPC 파트를 읽어보았다.</li>
  <li><code class="language-plaintext highlighter-rouge">void * __builtin_return_address(unsigned int level)</code> 함수에 대해 알아보았다. (<a href="https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html">link</a>)</li>
</ul>

<h2 id="220118tue">22.01.18.Tue</h2>
<ul>
  <li>Sanitizer Coverage를 이용해 function coverage를 얻는 방법을 알기 위해 Sanitizer Coverage를 공부했다. (<a href="https://clang.llvm.org/docs/SanitizerCoverage.html#id2">link1</a>, <a href="https://calabi-yau.space/blog/sanitizer-coverage-interface.html">link2</a>)</li>
  <li><a href="https://github.com/KimSeoYe/FunCov">FunCov</a>(function coverage tool)를 만들기 시작했다.</li>
</ul>

<h2 id="220124mon">22.01.24.Mon</h2>
<ul>
  <li>Sanitizer Coverage가 function entry point를 구분하는 방법을 찾기 위해 <a href="https://github.com/llvm/llvm-project">llvm-project</a> 코드를 보기 시작했다.
    <ul>
      <li>function entry point를 구분하여 추후 AFL++ 안에서 function coverage를 잴 수 있는 옵션을 추가하는 것이 목적</li>
    </ul>
  </li>
</ul>

<h2 id="220126wed">22.01.26.Wed</h2>
<ul>
  <li>Function pair coverage를 측정하기 위해 caller function에 대한 정보를 얻어오는 방법을 찾아보았음
    <ul>
      <li><a href="https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html"><code class="language-plaintext highlighter-rouge">void * __builtin_return_address(int level)</code></a></li>
    </ul>
  </li>
</ul>

